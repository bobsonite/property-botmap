<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Student Housing â€” Bot + Map</title>
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
  <style>
    html, body { margin:0; height:100%; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    .wrap { display:flex; height:100vh; }
    /* changed: botPane is now a DIV, not an iframe */
    #botPane { width: 28vw; min-width: 320px; border: 0; overflow:auto; }
    #map { flex: 1; }
    .topbar { position:absolute; right:12px; top:12px; background:#fff; padding:8px 10px; border-radius:10px; box-shadow:0 2px 10px rgba(0,0,0,.08); z-index:2; font-size:12px;}
    .pill { display:inline-block; background:#f2f2f2; padding:2px 8px; border-radius:999px; margin-left:6px; }

    .pin { width:30px; height:30px; border-radius:50%; display:flex; align-items:center; justify-content:center; font-size:18px; background:#fff; box-shadow:0 1px 6px rgba(0,0,0,.18); border:1px solid #ddd; }
    .pin--prop { border-color:#2563eb; }
    .pin--uni  { border-color:#16a34a; }
    .pin--poi  { border-color:#a855f7; }
  </style>
</head>
<body>
  <div class="wrap">
    <!-- changed: div instead of iframe -->
    <div id="botPane" title="Student Bot"></div>
    <div id="map"></div>
    <div class="topbar">
      session_id: <span id="sid" class="pill"></span>
    </div>
  </div>

  <!-- Libs -->
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <script src="https://cdn.ably.com/lib/ably.min-1.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <!-- NEW: Landbot SDK -->
  <script type="module" src="https://cdn.landbot.io/landbot-3/landbot-3.0.0.mjs"></script>

  <script type="module">
    /************ CONFIG ************/
    const MAPBOX_TOKEN      = 'pk.eyJ1IjoiYm9ic29uaXRlIiwiYSI6ImNtOXpyeWc1aDFlY24ya3M3dm55a2oyNDcifQ.8H2wkga07prlTm_YpOQicA';
    const ABLY_CLIENT_KEY   = 'Pc6iLw.uon00w:xfKlxamIh-D0uHTtyW5l_VOzDdk2BEFjyeHsGYcC4N0';
    const SUPABASE_URL      = 'https://fobibwavppcxfqpshrfp.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZvYmlid2F2cHBjeGZxcHNocmZwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTM2MDM2NTMsImV4cCI6MjA2OTE3OTY1M30.8QhebFQ8i0A5nUmz_g4cQ0ncbTgncsT6ZWNlRGZyLSM';

    /* add your bot config url here */
    const LANDBOT_CONFIG_URL = 'https://storage.googleapis.com/landbot.pro/v3/H-3134109-L1UF7O5PAQOKJEPB/index.json';

    /********************************/

    // Session id (used for Landbot + Ably channel)
    function newId() { return (crypto && crypto.randomUUID) ? crypto.randomUUID() : Math.random().toString(36).slice(2); }
    const urlParams = new URLSearchParams(location.search);
    const sessionId = urlParams.get('session_id') || newId();
    document.getElementById('sid').textContent = sessionId;

    // INIT Landbot in left panel (Container embed, not iframe)
    // We pass session_id so your n8n flow can publish to `filters:<session_id>`
    const lb = new window.Landbot.Container({
      container: '#botPane',
      configUrl: LANDBOT_CONFIG_URL,
      variables: {
        session_id: sessionId
      }
    });

    // Map
    mapboxgl.accessToken = MAPBOX_TOKEN;
    const map = new mapboxgl.Map({
      container: 'map',
      style: 'mapbox://styles/mapbox/light-v11',
      center: [-0.1276, 51.5072],
      zoom: 9
    });

    // Supabase + Ably (session-scoped)
    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    const ably = new Ably.Realtime({ key: ABLY_CLIENT_KEY, clientId: sessionId });
    const channel = ably.channels.get(`filters:${sessionId}`);

    // ---- NEW: fetch properties by propIDs from test_prop (the table your colleague uses) ----
async function fetchPropsByIds(propIDs){
  if (!Array.isArray(propIDs) || !propIDs.length) return [];

  // Supabase columns used by your colleague: Long/Lat (note the capital L), property, city, adress, etc.
  const { data, error } = await supabase
    .from('test_prop')
    .select('propID, property, city, adress, Long, Lat, property_description, owner, link')
    .in('propID', propIDs.map(String));

  if (error) { console.error('[supabase] test_prop fetch error', error); return []; }

  // Normalize to your marker shape
  const out = [];
  for (const r of data){
    const lat = r.Lat ?? r.lat ?? null;
    const lon = r.Long ?? r.long ?? r.lng ?? null;

    // If for any row Lat/Long are missing, fall back to geocoding the address
    let g = null;
    if (lat == null || lon == null){
      const q = r.adress || `${r.property||''}, ${r.city||''}, UK`;
      g = await geocodeAddress(q);
    }

    const finalLat = lat ?? g?.lat;
    const finalLon = lon ?? g?.lon;
    if (finalLat == null || finalLon == null) continue;

    out.push({
      id: r.propID,
      propID: r.propID,
      property: r.property,
      city: r.city,
      address: r.adress,
      link: r.link || null,
      lat: finalLat,
      lon: finalLon,
      _kind: 'prop'
    });
  }
  return out;
}

    // ---- NEW: listen to your colleague's simple 'props' channel ----
// NOTE: his n8n currently publishes to a *global* 'props' channel (no session).
// Until n8n adds session scoping, these messages are shared across all visitors.
const propsChannel = ably.channels.get('props');

propsChannel.subscribe('props', async (msg) => {
  // Accept array OR comma-separated string
  const raw = msg?.data?.propIDs;
  const ids = Array.isArray(raw)
    ? raw.map(v => String(v).trim()).filter(Boolean)
    : String(raw ?? '')
        .split(',')
        .map(s => s.trim())
        .filter(Boolean);

  if (!ids.length) return;

  // Show only those properties, using the same table your colleague uses
  clearMarkers();
  const rows = await fetchPropsByIds(ids);
  rows.forEach(addOrMoveMarker);
  fitToMarkers();
});
    window.ably = ably;

    // ---------------- Marker helpers ----------------
    const markersById = new Map();

    function iconFor({kind='poi', type=''}) {
      const t = String(type||'').toLowerCase();
      if (kind === 'uni')  return {emoji:'ðŸŽ“', cls:'pin--uni'};
      if (kind === 'prop') return {emoji:'ðŸ ', cls:'pin--prop'};
      if (t.includes('restaurant')) return {emoji:'ðŸ½ï¸', cls:'pin--poi'};
      if (t.includes('cafe') || t.includes('coffee')) return {emoji:'â˜•', cls:'pin--poi'};
      if (t.includes('bar') || t.includes('pub')) return {emoji:'ðŸº', cls:'pin--poi'};
      return {emoji:'ðŸ“', cls:'pin--poi'};
    }

    function makeMarkerEl(kind, type) {
      const el = document.createElement('div');
      const meta = iconFor({kind, type});
      el.className = `pin ${meta.cls}`;
      el.textContent = meta.emoji;
      return el;
    }

    function fmtMeters(m){
      if (m == null) return '';
      return m >= 1000 ? (m/1000).toFixed(1) + ' km' : m + ' m';
    }

    function addOrMoveMarker(row) {
      const id   = row.propid ?? row.propID ?? row.id ?? row.property ?? row.name;
      const kind = row._kind || 'poi';
      const type = row._type || row.type || row.type_single || '';

      const marker = markersById.get(id) ?? new mapboxgl.Marker({ element: makeMarkerEl(kind, type), anchor:'bottom' });

      const walk  = (row.time_walking!=null || row.distance_walking!=null)
        ? `ðŸš¶ ${row.time_walking!=null ? Math.round(row.time_walking/60)+' min' : ''}${row.distance_walking!=null ? ' Â· '+fmtMeters(row.distance_walking) : ''}`
        : '';
      const cycle = (row.time_cycling!=null || row.distance_cycling!=null)
        ? ` Â· ðŸš² ${row.time_cycling!=null ? Math.round(row.time_cycling/60)+' min' : ''}${row.distance_cycling!=null ? ' Â· '+fmtMeters(row.distance_cycling) : ''}`
        : '';
      const trans = (row.time_transport!=null || row.distance_transport!=null)
        ? ` Â· ðŸš— ${row.time_transport!=null ? Math.round(row.time_transport/60)+' min' : ''}${row.distance_transport!=null ? ' Â· '+fmtMeters(row.distance_transport) : ''}`
        : '';
      const dist  = row._distance_m ? ` Â· ${fmtMeters(row._distance_m)}` : '';

      marker
        .setLngLat([row.lon, row.lat])
        .setPopup(new mapboxgl.Popup({ offset: 8 }).setHTML(`
          <div style="font-size:13px; line-height:1.35">
            <div style="font-weight:600">${row.property || row.name || ''}</div>
            <div style="color:#666">${row.city || row.address || ''}</div>
            <div style="color:#444; margin-top:4px">${[walk,cycle,trans,dist].filter(Boolean).join('')}</div>
            ${row.link ? `<div style="margin-top:6px"><a href="${row.link}" target="_blank" rel="noopener">Open page â†’</a></div>` : ''}
          </div>
        `))
        .addTo(map);

      markersById.set(id, marker);
    }

    function clearMarkers(){ for (const m of markersById.values()) m.remove(); markersById.clear(); }
    function fitToMarkers(pad=60){
      const coords = [...markersById.values()].map(m => m.getLngLat());
      if (!coords.length) return;
      if (coords.length===1){ map.flyTo({ center: coords[0], zoom: 14, duration: 600 }); return; }
      const b = new mapboxgl.LngLatBounds(coords[0], coords[0]); coords.forEach(c => b.extend(c));
      map.fitBounds(b, { padding: pad, duration: 700 });
    }

    // ---------------- Geocoding (with cache) ----------------
    const _geoCache = new Map();
    async function geocodeAddress(q){
      if (!q) return null;
      const key = q.trim().toLowerCase();
      if (_geoCache.has(key)) return _geoCache.get(key);
      const url = new URL(`https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(q)}.json`);
      url.searchParams.set('access_token', MAPBOX_TOKEN);
      url.searchParams.set('limit','1');
      try {
        const r = await fetch(url); const j = await r.json();
        const f = j.features?.[0];
        if (f?.center?.length===2){
          const val = { lon:f.center[0], lat:f.center[1] };
          _geoCache.set(key, val);
          return val;
        }
      } catch(e){ console.error('geocode failed', e); }
      return null;
    }

    // ---------------- Properties by name ----------------
    async function fetchPropertiesByNames(names) {
      const results = [];
      const { data: exact, error: e1 } = await supabase.from('properties')
        .select('propID, property, city, adress, link')
        .in('property', names);
      if (!e1 && Array.isArray(exact)) results.push(...exact);

      const missing = names.filter(n => !results.some(r => (r.property||'').toLowerCase() === n.toLowerCase()));
      for (const n of missing) {
        const { data, error } = await supabase.from('properties')
          .select('propID, property, city, adress, link')
          .ilike('property', `%${n}%`);
        if (!error && Array.isArray(data) && data[0]) results.push(data[0]);
      }

      const enriched = [];
      for (const row of results) {
        let { lat, lon } = row;
        if (lat==null || lon==null) {
          const q = row.adress || `${row.property||''}, ${row.city||''}, UK`;
          const geo = await geocodeAddress(q);
          if (geo) { lat=geo.lat; lon=geo.lon; }
        }
        if (lat!=null && lon!=null) enriched.push({ ...row, lat, lon, _kind:'prop' });
      }
      return enriched;
    }

    // ---------------- Utils ----------------
    const metersBetween = (a,b) => {
      const R=6371000,toRad=d=>d*Math.PI/180;
      const dLat=toRad(b.lat-a.lat), dLon=toRad(b.lon-a.lon);
      const la1=toRad(a.lat), la2=toRad(b.lat);
      const h=Math.sin(dLat/2)**2 + Math.cos(la1)*Math.cos(la2)*Math.sin(dLon/2)**2;
      return 2*R*Math.asin(Math.sqrt(h));
    };
    function normalizeLatLon(row){
      const lat = row.lat ?? row.latitude ?? row.Lat ?? row.Latitude;
      const lon = row.lon ?? row.lng ?? row.long ?? row.longitude ?? row.Lon ?? row.Longitude;
      return (lat!=null && lon!=null) ? {lat:Number(lat), lon:Number(lon)} : null;
    }
    function pick(row, names, fallback=null){ for (const k of names){ if (row[k]!==undefined && row[k]!==null) return row[k]; } return fallback; }

    // ---------- University name normalization ----------
    function normText(s){
      return String(s ?? '')
        .toLowerCase()
        .replace(/['â€™`]/g, "'")
        .replace(/\s+/g, ' ')
        .trim();
    }
    function uniNeedle(raw=''){
      const n = normText(raw);
      const aliases = {
        'ucl': 'university college london',
        'kcl': "king's college london",
        'imperial': 'imperial college london'
      };
      return aliases[n] || n;
    }

    // ---------- University â†’ closest properties ----------
    async function fetchNearestPropsByUniversity(universityName, { owner=null, limit=8 } = {}, uniGeo=null){
      const { data, error } = await supabase.from('university_distance_final').select('*').limit(2000);
      if (error || !Array.isArray(data)) { console.error('[supabase] uni query error', error); return []; }

      const needle = uniNeedle(universityName);

      let rows = data.map(r => ({
        _raw:r,
        university: pick(r, ['University','university','uni_name','uni']),
        city:       pick(r, ['City','city']),
        property:   pick(r, ['Property','property','prop_name','name']),
        owner:      pick(r, ['Owner','owner','provider']),
        propID:     pick(r, ['propID','propId','prop_id','property_id','PropID']) ?? null,
        addrProp:   pick(r, ['Adress Prop','Address Prop','address_prop','property_address','AdressProp','address']),
        distance_walking:   pick(r, ['distance_walking','dist_walk_m','walk_m']),
        time_walking:       pick(r, ['time_walking','walk_time_s','walk_s']),
        distance_cycling:   pick(r, ['distance_cycling','cycle_m']),
        time_cycling:       pick(r, ['time_cycling','cycle_s']),
        distance_transport: pick(r, ['distance_transport','transit_m']),
        time_transport:     pick(r, ['time_transport','transit_s'])
      }))
      .filter(r => r.university && normText(r.university).includes(needle));

      if (owner) rows = rows.filter(r => normText(r.owner||'') === normText(owner));

      if (!uniGeo) uniGeo = await geocodeAddress(`${universityName}, UK`);

      const geoCache = new Map();
      for (const r of rows){
        const addr = r.addrProp || `${r.property||''}, ${r.city||''}, UK`;
        if (!geoCache.has(addr)) geoCache.set(addr, await geocodeAddress(addr));
        const g = geoCache.get(addr);
        if (g){ r.lat = g.lat; r.lon = g.lon; }
        r._fallback_m = (g && uniGeo) ? metersBetween({lat:g.lat, lon:g.lon}, uniGeo) : null;
      }

      rows.sort((a,b)=>{
        const av = [
          (a.time_walking!=null ? Number(a.time_walking) : Infinity),
          (a.distance_walking!=null ? Number(a.distance_walking) : Infinity),
          (a._fallback_m!=null ? a._fallback_m : Infinity)
        ];
        const bv = [
          (b.time_walking!=null ? Number(b.time_walking) : Infinity),
          (b.distance_walking!=null ? Number(b.distance_walking) : Infinity),
          (b._fallback_m!=null ? b._fallback_m : Infinity)
        ];
        for (let i=0;i<3;i++){ if (av[i]!==bv[i]) return av[i]-bv[i]; }
        return 0;
      });

      if (limit) rows = rows.slice(0, limit);

      const out = [];
      for (const r of rows){
        if (r.lat==null || r.lon==null) continue;
        out.push({
          id: r.propID ?? r.property,
          propID: r.propID ?? null,
          property: r.property,
          city: r.city,
          owner: r.owner,
          link: null,
          lat: r.lat, lon: r.lon,
          distance_walking: r.distance_walking,
          time_walking: r.time_walking,
          time_cycling: r.time_cycling,
          time_transport: r.time_transport,
          _kind:'prop'
        });
      }
      return out;
    }

    const PLACES_TABLE = 'Places_final';

    // ---------------- Places near a coordinate ----------------
    async function fetchPlacesNear(center, { radiusMeters=800, types=[], perTypeLimit=10, propertyName=null, propID=null } = {}){
      let q = supabase.from(PLACES_TABLE).select('*').limit(500);
      if (propID!=null) q = q.eq('propID', String(propID));
      else if (propertyName) q = q.ilike('Property', `%${propertyName}%`);
      const { data, error } = await q;
      if (error) { console.error('[supabase] places query error', error); return []; }

      const typeCol = data.length ? (['type_single','type','category','kind','place_type','tag'].find(k => k in data[0]) || null) : null;

      let rows = data;
      if (types.length && typeCol){
        const want = types.map(s => String(s).toLowerCase());
        rows = rows.filter(r => want.includes(String(r[typeCol]||'').toLowerCase()));
      }

      const buckets = new Map();
      const gcache = _geoCache;
      for (const r of rows){
        let geo = normalizeLatLon(r);
        if (!geo && r.Address){
          const cached = gcache.get(r.Address.toLowerCase());
          geo = cached || await geocodeAddress(r.Address);
        }
        if (!geo) continue;

        const d = center ? metersBetween(center, geo) : null;
        if (center && d > radiusMeters) continue;

        const t = (typeCol ? String(r[typeCol]||'').toLowerCase() : 'poi');
        if (!buckets.has(t)) buckets.set(t, []);
        if (buckets.get(t).length >= perTypeLimit) continue;

        buckets.get(t).push({
          id: r.UID || r.name,
          name: r.name,
          address: r.Address || '',
          lat: geo.lat, lon: geo.lon,
          _type: t, _kind:'poi',
          _distance_m: d ? Math.round(d) : null
        });
      }

      return [...buckets.values()].flat().sort((a,b)=> (a._distance_m ?? 0) - (b._distance_m ?? 0));
    }

    // ---------------- Center helpers for a property ----------------
    async function centerForProperty(propertyName){
      const { data } = await supabase.from('properties')
        .select('property, city, adress')
        .ilike('property', `%${propertyName}%`)
        .limit(1);
      let q = (data && data[0]) ? (data[0].adress || `${data[0].property}, ${data[0].city||''}, UK`) : propertyName;
      const geo = await geocodeAddress(q);
      return geo;
    }

    // ---------------- Route helpers ----------------
    function removeRoute(lineId='route-line', srcId='route-src'){
      if (map.getLayer(lineId))  map.removeLayer(lineId);
      if (map.getSource(srcId)) map.removeSource(srcId);
    }

    async function drawRoute(from, to, { profile='walking', lineId='route-line' } = {}){
      if (!map.isStyleLoaded()) await new Promise(res => map.once('load', res));
      const url = new URL(`https://api.mapbox.com/directions/v5/mapbox/${profile}/${from.lon},${from.lat};${to.lon},${to.lat}`);
      url.searchParams.set('geometries','geojson');
      url.searchParams.set('overview','full');
      url.searchParams.set('access_token', MAPBOX_TOKEN);
      try {
        const r = await fetch(url); const j = await r.json(); const route = j?.routes?.[0];
        if (!route?.geometry) return null;
        const srcId = 'route-src';
        if (!map.getSource(srcId)){
          map.addSource(srcId, { type:'geojson', data: route.geometry });
          map.addLayer({ id: lineId, type:'line', source: srcId, paint: { 'line-width': 4, 'line-color': '#3b82f6', 'line-opacity': 0.85 } });
        } else { map.getSource(srcId).setData(route.geometry); }
        return { distance_m: route.distance, duration_s: route.duration };
      } catch(e){ console.error('directions fetch failed', e); return null; }
    }

    // ---------------- Ably subscriber (session-scoped) ----------------
    channel.subscribe('filter_update', async (message) => {
      const p = message.data || {};
      console.log('[Ably] filter_update', p);

      removeRoute();

      if (p.viewport?.bbox && Array.isArray(p.viewport.bbox) && p.viewport.bbox.length === 4) {
        const [minLon, minLat, maxLon, maxLat] = p.viewport.bbox;
        map.fitBounds([[minLon, minLat], [maxLon, maxLat]], { padding: 48, duration: 800 });
      } else if (p.viewport?.center) {
        map.flyTo({ center: p.viewport.center, zoom: p.viewport.zoom ?? 12, duration: 800 });
      }

      if (Array.isArray(p.properties) && p.properties.length) {
        clearMarkers();
        const rows = await fetchPropertiesByNames(p.properties);
        rows.forEach(addOrMoveMarker);
        fitToMarkers();
        return;
      }

      if (p.uni) {
        clearMarkers();

        const uniGeo = await geocodeAddress(`${p.uni}, UK`);
        if (uniGeo) addOrMoveMarker({ id:`uni:${p.uni}`, property:p.uni, city:'', lat:uniGeo.lat, lon:uniGeo.lon, _kind:'uni' });

        const props = await fetchNearestPropsByUniversity(
          p.uni,
          { owner: p.owner ?? null, limit: p.limit ?? 5 },
          uniGeo
        );

        props.forEach(addOrMoveMarker);
        fitToMarkers();

        if (p.places && props[0]) {
          const center = { lat: props[0].lat, lon: props[0].lon };
          const near = await fetchPlacesNear(center, {
            radiusMeters: p.places.radiusMeters ?? 800,
            types: (p.places.types || []).map(s => String(s).toLowerCase()),
            perTypeLimit: p.places.perTypeLimit ?? 10,
            propertyName: props[0].property,
            propID: props[0].propID ?? null
          });
          near.forEach(addOrMoveMarker);
          fitToMarkers();
        }

        if (p.route?.draw === true && props[0] && uniGeo) {
          await drawRoute({ lat: props[0].lat, lon: props[0].lon }, uniGeo, { profile: p.route.profile ?? 'walking' });
        }
        return;
      }

      if (p.poiForProperty?.name || p.poiForProperty?.propID){
        clearMarkers();

        let center = null;
        if (p.poiForProperty.propID){
          const { data } = await supabase.from(PLACES_TABLE).select('Property').eq('propID', String(p.poiForProperty.propID)).limit(1);
          const propName = data?.[0]?.Property;
          center = propName ? await centerForProperty(propName) : null;
          if (!center && propName) center = await geocodeAddress(propName);
        } else {
          center = await centerForProperty(p.poiForProperty.name) || await geocodeAddress(p.poiForProperty.name);
        }

        if (center){
          addOrMoveMarker({ id:`prop-center:${p.poiForProperty.name || p.poiForProperty.propID}`, property:(p.poiForProperty.name||'Property'), lat:center.lat, lon:center.lon, _kind:'prop' });
        }

        const near = await fetchPlacesNear(center, {
          propertyName: p.poiForProperty.name || null,
          propID: p.poiForProperty.propID ?? null,
          radiusMeters: p.poiForProperty.radiusMeters ?? 800,
          types: (p.poiForProperty.types || []).map(s => String(s).toLowerCase()),
          perTypeLimit: p.poiForProperty.perTypeLimit ?? 10
        });

        near.forEach(addOrMoveMarker);
        fitToMarkers();
        return;
      }
    });

    // Console helper
    window._debugPublish = (payloadOrNames) => {
      const sid = document.getElementById('sid').textContent;
      const ch  = ably.channels.get(`filters:${sid}`);
      if (Array.isArray(payloadOrNames)) ch.publish('filter_update', { properties: payloadOrNames });
      else ch.publish('filter_update', payloadOrNames);
    };
  </script>
</body>
</html>