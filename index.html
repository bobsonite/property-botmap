<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Student Housing ‚Äî Bot + Map</title>
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />

  <style>
    :root{
      --bg:#ffffff;
      --text:#111827;
      --muted:#6b7280;
      --card:#ffffff;
      --card-border:#e5e7eb;
      --card-hover:#f6f9ff;
      --popup-bg:#ffffff;
      --popup-text:#111827;
      --chip-bg:#f3f4f6;
      --chip-text:#111827;
      --accent:#2563eb;
      --accent-2:#a855f7;

      /* Rings */
      --ring-500: rgba(37,99,235,.10);
      --ring-1000: rgba(37,99,235,.07);
      --ring-2000: rgba(37,99,235,.05);
      --ring-stroke:#2563eb;
      --ring-label:#1f2937;
      --ring-halo:#ffffff;
    }
    html[data-theme="dark"]{
      --bg:#0b1220;
      --text:#e5e7eb;
      --muted:#9aa3b2;
      --card:#0f172a;
      --card-border:#1f2937;
      --card-hover:#152341;
      --popup-bg:#0f172a;
      --popup-text:#e5e7eb;
      --chip-bg:#1f2937;
      --chip-text:#e5e7eb;

      --ring-500: rgba(59,130,246,.20);
      --ring-1000: rgba(59,130,246,.14);
      --ring-2000: rgba(59,130,246,.10);
      --ring-stroke:#60a5fa;
      --ring-label:#e5e7eb;
      --ring-halo:#0b1220;
    }
    html[data-theme="streets"]{ /* same palette as light */ }

    html, body { margin:0; height:100%; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:var(--bg); color:var(--text); }
    .wrap { display:flex; height:100vh; }

    #botPane { width:28vw; min-width:320px; overflow:auto; }
    #map     { flex:1; position:relative; }
    #listPane{
      width:25vw; min-width:300px; max-width:480px; overflow:auto;
      border-left:1px solid var(--card-border); background:var(--bg);
    }

    .topbar {
      position:absolute; right:12px; top:12px; z-index:2;
      background:var(--card); color:var(--text);
      padding:6px 8px; border-radius:12px; box-shadow:0 2px 10px rgba(0,0,0,.08);
      display:flex; align-items:center; gap:8px; border:1px solid var(--card-border);
      font-size:12px;
    }
    .pill { background:var(--chip-bg); color:var(--chip-text); padding:2px 8px; border-radius:999px; }
    .toggle { border:1px solid var(--card-border); border-radius:999px; padding:2px; display:inline-flex; gap:2px; background:var(--chip-bg); }
    .toggle button{ font-size:12px; border:0; padding:4px 8px; background:transparent; color:var(--chip-text); border-radius:999px; cursor:pointer; }
    .toggle button[aria-pressed="true"]{ background:var(--card); color:var(--text); }

    /* Markers */
    .pin{
      width:30px; height:30px; display:flex; align-items:center; justify-content:center;
      background:var(--card); border:1px solid var(--card-border);
      border-radius:50%; box-shadow:0 1px 6px rgba(0,0,0,.18);
      font-size:18px; transition:transform .12s ease, box-shadow .12s ease, background .12s ease;
    }
    .pin--prop { outline:2px solid #2563eb22; }
    .pin--poi  { outline:2px solid #a855f722; }
    .pin.is-hot{ transform:scale(1.1); box-shadow:0 2px 10px rgba(37,99,235,.35); }

    /* Cards */
    .card{
      background:var(--card); color:var(--text); margin:12px; padding:14px; border-radius:12px;
      box-shadow:0 1px 8px rgba(0,0,0,0.06);
      transition:transform .12s ease, background .12s ease, outline .12s ease;
      border:1px solid var(--card-border); cursor:pointer;
    }
    .card:hover{ transform:translateY(-1px); }
    .card.is-active{ outline:2px solid #2563eb22; background:var(--card-hover); }
    .card h3{ margin:0 0 4px; font-size:15px; }
    .meta{ color:var(--muted); font-size:12px; }
    .addr{ color:var(--muted); font-size:12px; margin-top:6px; }
    .desc{
      color:var(--text); opacity:.9; font-size:13px; margin-top:8px; line-height:1.35;
      display:-webkit-box; -webkit-line-clamp:5; line-clamp:5; -webkit-box-orient:vertical; overflow:hidden;
    }
    .chips{ display:flex; gap:6px; flex-wrap:wrap; margin-top:8px; }
    .chip{ display:inline-flex; align-items:center; gap:6px; font-size:12px; padding:4px 8px; border-radius:999px; background:var(--chip-bg); color:var(--chip-text); border:1px solid var(--card-border); }
    .chip b{ font-weight:600; }
    .link{ margin-top:8px; font-size:13px; }
    .empty{ color:var(--muted); font-size:13px; padding:14px; margin:12px; border:1px dashed var(--card-border); border-radius:10px; background:var(--card); }

    /* Mapbox popups honor theme */
    .mapboxgl-popup-content{ background:var(--popup-bg) !important; color:var(--popup-text) !important; }
    .mapboxgl-popup-tip{ border-top-color:var(--popup-bg) !important; border-bottom-color:var(--popup-bg) !important; }

    @media (max-width:980px){ #listPane{ display:none; } }
  </style>
</head>
<body>
  <div class="wrap">
    <div id="botPane" title="Student Bot"></div>

    <div id="map">
      <div class="topbar">
        <span class="pill">session_id: <span id="sid"></span></span>
        <div class="toggle" role="group" aria-label="Theme">
          <button id="btnLight"   type="button" aria-pressed="true">Light</button>
          <button id="btnDark"    type="button" aria-pressed="false">Dark</button>
          <button id="btnStreets" type="button" aria-pressed="false">Streets</button>
        </div>
      </div>
    </div>

    <aside id="listPane"></aside>
  </div>

  <!-- Libs -->
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://cdn.ably.com/lib/ably.min-1.js"></script>
  <script type="module" src="https://cdn.landbot.io/landbot-3/landbot-3.0.0.mjs"></script>

  <script type="module">
    /************ CONFIG ************/
    const MAPBOX_TOKEN  = 'pk.eyJ1IjoiYm9ic29uaXRlIiwiYSI6ImNtOXpyeWc1aDFlY24ya3M3dm55a2oyNDcifQ.8H2wkga07prlTm_YpOQicA';
    const SUPABASE_URL  = 'https://fobibwavppcxfqpshrfp.supabase.co';
    const SUPABASE_KEY  = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZvYmlid2F2cHBjeGZxcHNocmZwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTM2MDM2NTMsImV4cCI6MjA2OTE3OTY1M30.8QhebFQ8i0A5nUmz_g4cQ0ncbTgncsT6ZWNlRGZyLSM';
    const PEER_ABLY_KEY = '9hDZwQ.LMHMDw:rHPAP8YjEeVfa5-SYle5UBnVtGpIFpck8fO4YH42Gp0';
    const LANDBOT_CONFIG_URL = 'https://storage.googleapis.com/landbot.pro/v3/H-3134109-L1UF7O5PAQOKJEPB/index.json';

    const STYLES = {
      light:   'mapbox://styles/mapbox/light-v11',
      dark:    'mapbox://styles/mapbox/dark-v11',
      streets: 'mapbox://styles/mapbox/streets-v12'
    };

    /************ Session + bot ************/
    const newId = () => (crypto?.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2));
    const params = new URLSearchParams(location.search);
    const sessionId = params.get('session_id') || newId();
    document.getElementById('sid').textContent = sessionId;

    new window.Landbot.Container({
      container: '#botPane',
      configUrl: LANDBOT_CONFIG_URL,
      variables: { session_id: sessionId }
    });

    /************ Theme ************/
    const btnLight   = document.getElementById('btnLight');
    const btnDark    = document.getElementById('btnDark');
    const btnStreets = document.getElementById('btnStreets');

    const stored = localStorage.getItem('theme') || 'light';
    const initialTheme = (stored in STYLES) ? stored : 'light';
    document.documentElement.setAttribute('data-theme', initialTheme);
    reflectPressed(initialTheme);

    function reflectPressed(mode){
      btnLight  .setAttribute('aria-pressed', mode==='light'   ? 'true':'false');
      btnDark   .setAttribute('aria-pressed', mode==='dark'    ? 'true':'false');
      btnStreets.setAttribute('aria-pressed', mode==='streets' ? 'true':'false');
    }

    function setTheme(mode){
      const t = (mode in STYLES) ? mode : 'light';
      document.documentElement.setAttribute('data-theme', t);
      reflectPressed(t);
      localStorage.setItem('theme', t);
      if (map.getStyle()?.sprite?.includes(t)) return;
      map.setStyle(STYLES[t]);
      map.once('style.load', () => {
        if (currentRingsGeo) addRingLayers(currentRingsGeo); // restore rings + labels after style change
      });
    }
    btnLight  .addEventListener('click', ()=> setTheme('light'));
    btnDark   .addEventListener('click', ()=> setTheme('dark'));
    btnStreets.addEventListener('click', ()=> setTheme('streets'));

    /************ Map ************/
    mapboxgl.accessToken = MAPBOX_TOKEN;
    const map = new mapboxgl.Map({
      container: 'map',
      style: STYLES[initialTheme],
      center: [-0.1276, 51.5072],
      zoom: 9
    });

    /************ Supabase + Ably ************/
    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
    const ably     = new Ably.Realtime(PEER_ABLY_KEY);
    const propsCh  = ably.channels.get('props');

    /************ State + helpers ************/
    const listPane     = document.getElementById('listPane');
    const markersProp  = new Map(); // propID -> Marker
    const markersPOI   = new Map(); // UID   -> Marker
    let   currentProps = [];        // props with _amenityCounts + _amenServIcons
    let   currentRingsGeo = null;   // FeatureCollection for polygons + labels
    let   hideRingsTimer = null;

    const escapeHtml = (s='') => String(s)
      .replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')
      .replace(/"/g,'&quot;').replace(/'/g,'&#39;');

    const emojiForType = (t='') => {
      const x = String(t).toLowerCase();
      if (x.includes('cafe') || x.includes('coffee')) return '‚òï';
      if (x.includes('bar')  || x.includes('pub'))    return 'üç∫';
      if (x.includes('restaurant') || x.includes('food')) return 'üçΩÔ∏è';
      if (x.includes('supermarket') || x.includes('grocery')) return 'üõí';
      if (x.includes('gym')) return 'üí™';
      if (x.includes('park')) return 'üå≥';
      return 'üìç';
    };

    // Amenity/Service ‚Üí icon mapper
    function emojiForAmenityOrService(label=''){
      const s = String(label).toLowerCase();
      if (/\b(cctv|security|secure|key fob|keycard|access control)\b/.test(s)) return 'üõ°Ô∏è';
      if (/\b(24.?hour|24\/7|reception|on.?site team|maintenance)\b/.test(s)) return 'üë•';
      if (/\b(wifi|wi[- ]?fi|internet|broadband|high[- ]?speed)\b/.test(s))    return 'üì∂';
      if (/\b(utility|utilities|bills|electricity|gas|water)\b/.test(s))       return 'üí°';
      if (/\b(laundry|washer|dryer)\b/.test(s))                                 return 'üß∫';
      if (/\b(bike|cycle|bicycle)\b/.test(s))                                   return 'üö≤';
      if (/\b(parking|car|garage|charge)\b/.test(s))                            return 'üÖøÔ∏è';
      if (/\b(gym|fitness|yoga|wellness)\b/.test(s))                             return 'üí™';
      if (/\b(cinema|movie|tv lounge|karaoke|games?)\b/.test(s))                return 'üé¨';
      if (/\b(study|desk|library|booth|hub)\b/.test(s))                          return 'üìö';
      if (/\b(roof|terrace|sky lounge|garden|courtyard|outdoor)\b/.test(s))     return 'üåø';
      if (/\b(accessible|wheelchair|access ramp|lift|elevator)\b/.test(s))      return '‚ôø';
      if (/\b(air.?con(ditioning)?|ac)\b/.test(s))                               return '‚ùÑÔ∏è';
      if (/\b(dining|kitchen|hosting)\b/.test(s))                                return 'üçΩÔ∏è';
      if (/\b(insurance|howden)\b/.test(s))                                      return 'üßæ';
      return 'üè∑Ô∏è';
    }

    const makePin = (cls, text) => {
      const el = document.createElement('div');
      el.className = `pin ${cls}`;
      el.textContent = text;
      return el;
    };

    const _geoCache = new Map();
    async function geocodeAddress(q){
      if (!q) return null;
      const key = q.trim().toLowerCase();
      if (_geoCache.has(key)) return _geoCache.get(key);
      const url = new URL(`https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(q)}.json`);
      url.searchParams.set('access_token', MAPBOX_TOKEN);
      url.searchParams.set('limit','1');
      try {
        const r = await fetch(url); const j = await r.json(); const f = j.features?.[0];
        if (f?.center?.length===2){ const val = { lon:f.center[0], lat:f.center[1] }; _geoCache.set(key, val); return val; }
      } catch(e){ console.error('geocode fail', e); }
      return null;
    }

    function metersBetween(a,b){
      const R=6371000, toRad=d=>d*Math.PI/180;
      const dLat=toRad(b.lat-a.lat), dLon=toRad(b.lon-a.lon);
      const la1=toRad(a.lat), la2=toRad(b.lat);
      const h=Math.sin(dLat/2)**2 + Math.cos(la1)*Math.cos(la2)*Math.sin(dLon/2)**2;
      return 2*R*Math.asin(Math.sqrt(h));
    }

    function clearAllMarkers(){
      for (const m of markersProp.values()) m.remove(); markersProp.clear();
      for (const m of markersPOI.values())  m.remove();  markersPOI.clear();
      removeRings();
    }

    function fitToAllMarkers(pad=64){
      const all = [...markersProp.values(), ...markersPOI.values()];
      const coords = all.map(m => m.getLngLat());
      if (!coords.length) return;
      if (coords.length === 1){ map.flyTo({ center: coords[0], zoom: 13.5, duration: 700 }); return; }
      const b = new mapboxgl.LngLatBounds(coords[0], coords[0]); coords.forEach(c => b.extend(c));
      map.fitBounds(b, { padding: pad, duration: 800, maxZoom: 14 });
    }

    /************ Data fetchers ************/
    async function fetchPropsByIds(propIDs){
      if (!Array.isArray(propIDs) || !propIDs.length) return [];
      const { data, error } = await supabase
        .from('test_prop')
        .select('propID, property, city, adress, Long, Lat, link, owner, property_description')
        .in('propID', propIDs.map(String));
      if (error) { console.error('[supabase] test_prop error', error); return []; }

      const out = [];
      for (const r of data){
        let lat = r.Lat ?? null, lon = r.Long ?? null;
        if (lat==null || lon==null){
          const g = await geocodeAddress(r.adress || `${r.property||''}, ${r.city||''}, UK`);
          if (g){ lat=g.lat; lon=g.lon; }
        }
        if (lat==null || lon==null) continue;
        out.push({ ...r, lat, lon });
      }
      return out;
    }

    async function fetchAllProps(){
      const { data, error } = await supabase
        .from('test_prop')
        .select('propID, property, city, adress, Long, Lat, link, owner, property_description')
        .limit(500);
      if (error) { console.error('[supabase] fetchAllProps error', error); return []; }

      const out = [];
      for (const r of data){
        let lat = r.Lat ?? null, lon = r.Long ?? null;
        if (lat==null || lon==null){
          const g = await geocodeAddress(r.adress || `${r.property||''}, ${r.city||''}, UK`);
          if (g){ lat=g.lat; lon=g.lon; }
        }
        if (lat==null || lon==null) continue;
        out.push({ ...r, lat, lon });
      }
      return out;
    }

    async function fetchPOIsForProps(propIDs, { types=['cafe','bar','restaurant','gym','park'], perTypeLimit=8, radiusMeters=800 } = {}, centersByProp = new Map()){
      if (!propIDs?.length) return { list:[], counts:new Map() };

      const { data, error } = await supabase
        .from('Places_final')
        .select('UID, name, Address, type_single, propID')
        .in('propID', propIDs.map(String))
        .limit(2000);
      if (error) { console.error('[supabase] Places_final error', error); return { list:[], counts:new Map() }; }

      const want = new Set(types.map(t => String(t).toLowerCase()));
      const perType = new Map();
      const counts = new Map();
      const list = [];

      for (const r of data){
        const t = String(r.type_single||'').toLowerCase();
        if (types.length && !want.has(t)) continue;

        const g = await geocodeAddress(r.Address);
        if (!g) continue;

        const center = centersByProp.get(String(r.propID));
        const d = center ? metersBetween(center, g) : null;
        if (center && d!=null && d > radiusMeters) continue;

        const pid = String(r.propID);
        if (!counts.has(pid)) counts.set(pid, { cafe:0, bar:0, restaurant:0, gym:0, park:0 });
        const bucket = counts.get(pid);
        if (t.includes('cafe') || t.includes('coffee')) bucket.cafe++;
        else if (t.includes('bar') || t.includes('pub')) bucket.bar++;
        else if (t.includes('restaurant') || t.includes('food')) bucket.restaurant++;
        else if (t.includes('gym')) bucket.gym++;
        else if (t.includes('park')) bucket.park++;

        const used = perType.get(t) || 0;
        if (used < perTypeLimit){
          list.push({ id:r.UID, name:r.name, address:r.Address, type:r.type_single, propID:r.propID, lat:g.lat, lon:g.lon, _distance_m:d!=null?Math.round(d):null });
          perType.set(t, used+1);
        }
      }
      list.sort((a,b)=> (a._distance_m??1e12) - (b._distance_m??1e12));
      return { list, counts };
    }

    // NEW: fetch amenities + services icons per property
    async function fetchAmenAndServices(propIDs){
      const ids = (propIDs||[]).map(String);
      const byProp = new Map(ids.map(id => [id, { amen:[], serv:[] }]));

      // amenities
      {
        const { data, error } = await supabase
          .from('amenities')
          .select('property_id, propid, Amenity')
          .in('property_id', ids)
          .limit(5000);
        if (error || !data?.length){
          const r2 = await supabase
            .from('amenities')
            .select('propid, Amenity')
            .in('propid', ids)
            .limit(5000);
          if (!r2.error && r2.data){
            for (const r of r2.data){
              const pid = String(r.propid);
              if (byProp.has(pid)) byProp.get(pid).amen.push(String(r.Amenity||''));
            }
          }
        } else {
          for (const r of data){
            const pid = String(r.property_id ?? r.propid ?? '');
            if (byProp.has(pid)) byProp.get(pid).amen.push(String(r.Amenity||''));
          }
        }
      }

      // services
      {
        const { data, error } = await supabase
          .from('services')
          .select('property_id, propid, service')
          .in('property_id', ids)
          .limit(5000);
        if (error || !data?.length){
          const r2 = await supabase
            .from('services')
            .select('propid, service')
            .in('propid', ids)
            .limit(5000);
          if (!r2.error && r2.data){
            for (const r of r2.data){
              const pid = String(r.propid);
              if (byProp.has(pid)) byProp.get(pid).serv.push(String(r.service||''));
            }
          }
        } else {
          for (const r of data){
            const pid = String(r.property_id ?? r.propid ?? '');
            if (byProp.has(pid)) byProp.get(pid).serv.push(String(r.service||''));
          }
        }
      }

      const result = new Map();
      for (const [pid, {amen, serv}] of byProp.entries()){
        const amenIcons = [...new Set(amen.map(emojiForAmenityOrService))];
        const servIcons = [...new Set(serv.map(emojiForAmenityOrService))];
        result.set(pid, { amenIcons, servIcons });
      }
      return result;
    }

    /************ Proximity rings (+ labels) ************/
    function destPoint(lon,lat,distMeters,bearingDeg){
      const R=6371000, br=bearingDeg*Math.PI/180, œÜ1=lat*Math.PI/180, Œª1=lon*Math.PI/180, d=distMeters/R;
      const œÜ2=Math.asin(Math.sin(œÜ1)*Math.cos(d)+Math.cos(œÜ1)*Math.sin(d)*Math.cos(br));
      const Œª2=Œª1+Math.atan2(Math.sin(br)*Math.sin(d)*Math.cos(œÜ1),Math.cos(d)-Math.sin(œÜ1)*Math.sin(œÜ2));
      return [Œª2*180/Math.PI, œÜ2*180/Math.PI];
    }
    function circlePolygon(lon, lat, radiusMeters, points=64){
      const coords = [];
      for (let i=0;i<=points;i++){
        const br = (i/points)*360;
        coords.push(destPoint(lon,lat,radiusMeters,br));
      }
      return { type:'Polygon', coordinates:[coords] };
    }
    function minsForRadius(r){ return Math.round(r/80); } // ~80 m/min ‚âà 5 km/h
    function ringsGeo(lon,lat){
      const radii=[500,1000,2000];
      const features=[];
      for (const r of radii){
        features.push({ type:'Feature', properties:{ kind:'ring', id:r }, geometry: circlePolygon(lon,lat,r) });
        const [lx,ly] = destPoint(lon,lat,r,95);
        const mins = minsForRadius(r);
        features.push({ type:'Feature', properties:{ kind:'label', id:r, text:`‚âà${mins} min walk` }, geometry:{ type:'Point', coordinates:[lx,ly] } });
      }
      return { type:'FeatureCollection', features };
    }
    function addRingLayers(geo){
      const SRC='rings-src', FILL='rings-fill', LINE='rings-line', LBL='rings-lbl';
      if (map.getLayer(LBL)) map.removeLayer(LBL);
      if (map.getLayer(LINE)) map.removeLayer(LINE);
      if (map.getLayer(FILL)) map.removeLayer(FILL);
      if (map.getSource(SRC)) map.removeSource(SRC);

      map.addSource(SRC, { type:'geojson', data: geo });

      map.addLayer({ id:FILL, type:'fill', source:SRC, filter:['==',['get','kind'],'ring'], paint:{
        'fill-color': ['match',['get','id'],
          500, getComputedStyle(document.documentElement).getPropertyValue('--ring-500').trim(),
          1000, getComputedStyle(document.documentElement).getPropertyValue('--ring-1000').trim(),
          2000, getComputedStyle(document.documentElement).getPropertyValue('--ring-2000').trim(),
          'rgba(37,99,235,0.08)'
        ],
        'fill-opacity': 1
      }});
      map.addLayer({ id:LINE, type:'line', source:SRC, filter:['==',['get','kind'],'ring'], paint:{
        'line-color': getComputedStyle(document.documentElement).getPropertyValue('--ring-stroke').trim(),
        'line-width': 1.2
      }});
      map.addLayer({ id:LBL, type:'symbol', source:SRC, filter:['==',['get','kind'],'label'], layout:{
        'text-field': ['get','text'],
        'text-font': ['Inter Medium','Open Sans Semibold','Arial Unicode MS Bold'],
        'text-size': 12,
        'text-offset': [0,0]
      }, paint:{
        'text-color': getComputedStyle(document.documentElement).getPropertyValue('--ring-label').trim(),
        'text-halo-color': getComputedStyle(document.documentElement).getPropertyValue('--ring-halo').trim(),
        'text-halo-width': 1.2
      }});
    }
    function removeRings(){
      const SRC='rings-src', FILL='rings-fill', LINE='rings-line', LBL='rings-lbl';
      if (map.getLayer(LBL))  map.removeLayer(LBL);
      if (map.getLayer(LINE)) map.removeLayer(LINE);
      if (map.getLayer(FILL)) map.removeLayer(FILL);
      if (map.getSource(SRC)) map.removeSource(SRC);
      currentRingsGeo = null;
    }
    function showRingsAt({lon,lat}){
      clearTimeout(hideRingsTimer);
      const geo = ringsGeo(lon,lat);
      currentRingsGeo = geo;
      addRingLayers(geo);
    }
    function scheduleHideRings(){
      clearTimeout(hideRingsTimer);
      hideRingsTimer = setTimeout(removeRings, 180);
    }

    /************ Draw ************/
    function drawProperty(p){
      const id = String(p.propID);
      const el = makePin('pin--prop','üè†');
      const marker = markersProp.get(id) ?? new mapboxgl.Marker({ element: el, anchor:'bottom' });

      const chipsPOI = p._amenityCounts ? makeChipRow(p._amenityCounts) : '';
      const chipsAS  = p._amenServIcons ? makeAmenityServiceRow(p._amenServIcons) : '';
      const html = `
        <div style="font-size:13px; line-height:1.35">
          <div style="font-weight:700">${escapeHtml(p.property||'')}</div>
          <div class="meta">${escapeHtml(p.city||'')}${p.owner ? ' ¬∑ '+escapeHtml(p.owner) : ''}</div>
          ${p.adress ? `<div class="addr">${escapeHtml(p.adress)}</div>` : ''}
          ${p.property_description ? `<div class="desc">${escapeHtml(p.property_description)}</div>` : ''}
          ${chipsPOI}${chipsAS}
          ${p.link ? `<div class="link"><a href="${p.link}" target="_blank" rel="noopener">Open page ‚Üí</a></div>` : ''}
        </div>`;

      marker
        .setLngLat([p.lon, p.lat])
        .setPopup(new mapboxgl.Popup({ offset:8, maxWidth:'320px' }).setHTML(html))
        .addTo(map);

      markersProp.set(id, marker);

      el.addEventListener('mouseenter', ()=> { toggleCardHot(id, true);  showRingsAt({lon:p.lon, lat:p.lat}); });
      el.addEventListener('mouseleave', ()=> { toggleCardHot(id, false); scheduleHideRings(); });
    }

    function drawPOI(r){
      const id = String(r.id);
      if (markersPOI.has(id)) return;
      const el = makePin('pin--poi', emojiForType(r.type));
      const m = new mapboxgl.Marker({ element: el, anchor:'bottom' })
        .setLngLat([r.lon, r.lat])
        .setPopup(new mapboxgl.Popup({ offset:8 }).setHTML(`
          <div style="font-size:13px; line-height:1.35">
            <div style="font-weight:700">${escapeHtml(r.name||'')}</div>
            <div class="meta">${escapeHtml(r.type||'')}</div>
            ${r.address ? `<div class="addr">${escapeHtml(r.address)}</div>` : ''}
          </div>`))
        .addTo(map);
      markersPOI.set(id, m);
    }

    function makeChipRow(a){
      const bits = [];
      if (a.cafe)       bits.push(`<span class="chip">‚òï <b>${a.cafe}</b></span>`);
      if (a.bar)        bits.push(`<span class="chip">üç∫ <b>${a.bar}</b></span>`);
      if (a.restaurant) bits.push(`<span class="chip">üçΩÔ∏è <b>${a.restaurant}</b></span>`);
      if (a.gym)        bits.push(`<span class="chip">üí™ <b>${a.gym}</b></span>`);
      if (a.park)       bits.push(`<span class="chip">üå≥ <b>${a.park}</b></span>`);
      return bits.length ? `<div class="chips">${bits.join('')}</div>` : '';
    }

    // NEW: render amenities/services icon row (up to N icons)
    function makeAmenityServiceRow({ amenIcons=[], servIcons=[] } = {}, maxTotal=8){
      const icons = [...amenIcons, ...servIcons].slice(0, maxTotal);
      if (!icons.length) return '';
      const html = icons.map(ic => `<span class="chip">${ic}</span>`).join('');
      return `<div class="chips">${html}</div>`;
    }

    /************ Shortlist UI ************/
    function renderList(props){
      currentProps = props;
      if (!props.length){
        listPane.innerHTML = `<div class="empty">No properties to display yet.<br/>Ask the bot for an area or a university üôÇ</div>`;
        return;
      }
      listPane.innerHTML = props.map(p => `
        <article class="card" data-id="${p.propID}">
          <h3>${escapeHtml(p.property||'')}</h3>
          <div class="meta">${escapeHtml(p.city||'')}${p.owner ? ' ¬∑ ' + escapeHtml(p.owner) : ''}</div>
          ${p.adress ? `<div class="addr">${escapeHtml(p.adress)}</div>` : ''}
          ${p.property_description ? `<div class="desc">${escapeHtml(p.property_description)}</div>` : ''}
          ${p._amenityCounts ? makeChipRow(p._amenityCounts) : ''}
          ${p._amenServIcons ? makeAmenityServiceRow(p._amenServIcons) : ''}
          ${p.link ? `<div class="link"><a href="${p.link}" target="_blank" rel="noopener">Open page ‚Üí</a></div>` : ''}
        </article>
      `).join('');

      listPane.querySelectorAll('.card').forEach(card => {
        const id = card.getAttribute('data-id');
        const row = () => currentProps.find(r => String(r.propID)===String(id));
        card.addEventListener('mouseenter', ()=> {
          const r = row(); if (!r) return;
          toggleMarkerHot(id, true);
          showRingsAt({lon:r.lon, lat:r.lat});
        });
        card.addEventListener('mouseleave', ()=> {
          toggleMarkerHot(id, false);
          scheduleHideRings();
        });
        card.addEventListener('click', ()=> {
          const r = row(); const m = markersProp.get(String(id));
          if (!m || !r) return;
          map.flyTo({ center:[r.lon,r.lat], zoom:14, duration:600 });
          setTimeout(()=> m.togglePopup(), 650);
        });
      });
    }

    function toggleMarkerHot(id, on){
      const m = markersProp.get(String(id));
      if (!m) return;
      m.getElement().classList.toggle('is-hot', !!on);
    }
    function toggleCardHot(id, on){
      const card = listPane.querySelector(`.card[data-id="${CSS.escape(String(id))}"]`);
      if (!card) return;
      card.classList.toggle('is-active', !!on);
    }

    /************ Ably subscription ************/
    function parsePropIDs(raw){
      if (Array.isArray(raw)) return raw.map(v => String(v).trim()).filter(Boolean);
      if (typeof raw === 'string'){
        const s = raw.trim();
        if (s.startsWith('[')) { try { return JSON.parse(s).map(String); } catch{} }
        return s.split(',').map(x => x.trim()).filter(Boolean);
      }
      return [];
    }

    propsCh.subscribe(async (msg) => {
      const ids = parsePropIDs(msg?.data?.propIDs);
      if (!ids.length) return;

      clearAllMarkers();

      const props = await fetchPropsByIds(ids);
      const centers = new Map(props.map(p => [String(p.propID), { lat:p.lat, lon:p.lon }]));
      const { list: pois, counts } = await fetchPOIsForProps(ids, { types:['cafe','bar','restaurant','gym','park'], perTypeLimit:8, radiusMeters:800 }, centers);

      // NEW: amenities & services icons
      const amenServ = await fetchAmenAndServices(ids);

      props.forEach(p => {
        const pid = String(p.propID);
        p._amenityCounts = counts.get(pid) || null;
        p._amenServIcons = amenServ.get(pid) || { amenIcons:[], servIcons:[] };
      });

      props.forEach(drawProperty);
      pois.forEach(drawPOI);

      renderList(props);
      fitToAllMarkers();
    });

    /************ Initial load ************/
    async function bootstrap(){
      const props = await fetchAllProps();
      if (!props.length) { renderList([]); return; }

      const centers = new Map(props.map(p => [String(p.propID), { lat:p.lat, lon:p.lon }]));
      const ids = props.map(p => String(p.propID));

      const { counts } = await fetchPOIsForProps(ids, { types:['cafe','bar','restaurant','gym','park'], perTypeLimit:0, radiusMeters:800 }, centers);
      const amenServ = await fetchAmenAndServices(ids);

      props.forEach(p => {
        const pid = String(p.propID);
        p._amenityCounts = counts.get(pid) || null;
        p._amenServIcons = amenServ.get(pid) || { amenIcons:[], servIcons:[] };
      });

      clearAllMarkers();
      props.forEach(drawProperty);
      renderList(props);
      fitToAllMarkers();
    }
    map.once('load', bootstrap);
  </script>
</body>
</html>