<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Student Housing ‚Äî Bot + Map</title>
  <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
  <style>
    html, body { margin:0; height:100%; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    .wrap { display:flex; height:100vh; }
    #botPane { width: 28vw; min-width: 320px; border: 0; }
    #map { flex: 1; }
    .topbar { position:absolute; right:12px; top:12px; background:#fff; padding:8px 10px; border-radius:10px; box-shadow:0 2px 10px rgba(0,0,0,.08); z-index:2; font-size:12px;}
    .pill { display:inline-block; background:#f2f2f2; padding:2px 8px; border-radius:999px; margin-left:6px; }
    .pin { width:30px; height:30px; border-radius:50%; display:flex; align-items:center; justify-content:center; font-size:18px; background:#fff; box-shadow:0 1px 6px rgba(0,0,0,.18); border:1px solid #ddd; }
    .pin--prop { border-color:#2563eb; }
    .pin--uni  { border-color:#16a34a; }
    .pin--poi  { border-color:#a855f7; }
  </style>
</head>
<body>
  <div class="wrap">
    <iframe id="botPane" title="Student Bot"></iframe>
    <div id="map"></div>
    <div class="topbar">
      session_id: <span id="sid" class="pill"></span>
    </div>
  </div>

  <!-- Libs -->
  <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
  <script src="https://cdn.ably.com/lib/ably.min-1.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <script>
    /************ CONFIG ************/
    const MAPBOX_TOKEN      = 'pk.eyJ1IjoiYm9ic29uaXRlIiwiYSI6ImNtOXpyeWc1aDFlY24ya3M3dm55a2oyNDcifQ.8H2wkga07prlTm_YpOQicA';
    const ABLY_CLIENT_KEY   = 'Pc6iLw.uon00w:xfKlxamIh-D0uHTtyW5l_VOzDdk2BEFjyeHsGYcC4N0';   // subscribe/publish ok
    const SUPABASE_URL      = 'https://fobibwavppcxfqpshrfp.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZvYmlid2F2cHBjeGZxcHNocmZwIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTM2MDM2NTMsImV4cCI6MjA2OTE3OTY1M30.8QhebFQ8i0A5nUmz_g4cQ0ncbTgncsT6ZWNlRGZyLSM';
    const BOT_URL = '';
    /********************************/

    // Session id
    function newId() { return (crypto && crypto.randomUUID) ? crypto.randomUUID() : Math.random().toString(36).slice(2); }
    const urlParams = new URLSearchParams(location.search);
    const sessionId = urlParams.get('session_id') || newId();
    document.getElementById('sid').textContent = sessionId;

    if (BOT_URL) {
      const botSrc = new URL(BOT_URL); botSrc.searchParams.set('session_id', sessionId);
      document.getElementById('botPane').src = botSrc.toString();
    }

    // Map
    mapboxgl.accessToken = MAPBOX_TOKEN;
    const map = new mapboxgl.Map({
      container: 'map',
      style: 'mapbox://styles/mapbox/light-v11',
      center: [-0.1276, 51.5072],
      zoom: 9
    });

    // Supabase + Ably
    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    const ably = new Ably.Realtime({ key: ABLY_CLIENT_KEY, clientId: sessionId });
    const channel = ably.channels.get(`filters:${sessionId}`);
    window.ably = ably;

    // ---------------- Marker helpers ----------------
    const markersById = new Map();

    function iconFor({kind='poi', type=''}) {
      const t = String(type||'').toLowerCase();
      if (kind === 'uni')  return {emoji:'üéì', cls:'pin--uni'};
      if (kind === 'prop') return {emoji:'üè†', cls:'pin--prop'};
      if (t.includes('restaurant')) return {emoji:'üçΩÔ∏è', cls:'pin--poi'};
      if (t.includes('cafe') || t.includes('coffee')) return {emoji:'‚òï', cls:'pin--poi'};
      if (t.includes('bar') || t.includes('pub')) return {emoji:'üç∫', cls:'pin--poi'};
      return {emoji:'üìç', cls:'pin--poi'};
    }

    function makeMarkerEl(kind, type) {
      const el = document.createElement('div');
      el.className = `pin ${iconFor({kind, type}).cls}`;
      el.textContent = iconFor({kind, type}).emoji;
      return el;
    }

    function addOrMoveMarker(row) {
      const id   = row.propid ?? row.propID ?? row.id ?? row.property ?? row.name;
      const kind = row._kind || 'poi'; // 'prop' | 'uni' | 'poi'
      const type = row._type || row.type || row.type_single || '';

      const marker = markersById.get(id) ?? new mapboxgl.Marker({ element: makeMarkerEl(kind, type), anchor:'bottom' });

      const walk  = row.time_walking     ? `üö∂ ${Math.round(row.time_walking/60)} min` : '';
      const cycle = row.time_cycling     ? ` ¬∑ üö≤ ${Math.round(row.time_cycling/60)} min` : '';
      const trans = row.time_transport   ? ` ¬∑ üöó ${Math.round(row.time_transport/60)} min` : '';
      const dist  = row._distance_m      ? ` ¬∑ ${row._distance_m} m` : '';

      marker
        .setLngLat([row.lon, row.lat])
        .setPopup(new mapboxgl.Popup({ offset: 8 }).setHTML(`
          <div style="font-size:13px; line-height:1.35">
            <div style="font-weight:600">${row.property || row.name || ''}</div>
            <div style="color:#666">${row.city || row.address || ''}</div>
            <div style="color:#444; margin-top:4px">${[walk,cycle,trans,dist].filter(Boolean).join('')}</div>
            ${row.link ? `<div style="margin-top:6px"><a href="${row.link}" target="_blank" rel="noopener">Open page ‚Üí</a></div>` : ''}
          </div>
        `))
        .addTo(map);

      markersById.set(id, marker);
    }

    function clearMarkers(){ for (const m of markersById.values()) m.remove(); markersById.clear(); }
    function fitToMarkers(pad=60){
      const coords = [...markersById.values()].map(m => m.getLngLat());
      if (!coords.length) return;
      if (coords.length===1){ map.flyTo({ center: coords[0], zoom: 14, duration: 600 }); return; }
      const b = new mapboxgl.LngLatBounds(coords[0], coords[0]); coords.forEach(c => b.extend(c));
      map.fitBounds(b, { padding: pad, duration: 700 });
    }

    // ---------------- Geocoding (with cache) ----------------
    const _geoCache = new Map(); // address -> {lat,lon}
    async function geocodeAddress(q){
      if (!q) return null;
      const key = q.trim().toLowerCase();
      if (_geoCache.has(key)) return _geoCache.get(key);
      const url = new URL(`https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(q)}.json`);
      url.searchParams.set('access_token', MAPBOX_TOKEN);
      url.searchParams.set('limit','1');
      try {
        const r = await fetch(url); const j = await r.json();
        const f = j.features?.[0];
        if (f?.center?.length===2){
          const val = { lon:f.center[0], lat:f.center[1] };
          _geoCache.set(key, val);
          return val;
        }
      } catch(e){ console.error('geocode failed', e); }
      return null;
    }

    // ---------------- Properties by name ----------------
    async function fetchPropertiesByNames(names) {
      const results = [];
      const { data: exact, error: e1 } = await supabase.from('properties')
        .select('propID, property, city, adress, link')
        .in('property', names);
      if (!e1 && Array.isArray(exact)) results.push(...exact);

      const missing = names.filter(n => !results.some(r => (r.property||'').toLowerCase() === n.toLowerCase()));
      for (const n of missing) {
        const { data, error } = await supabase.from('properties')
          .select('propID, property, city, adress, link')
          .ilike('property', `%${n}%`);
        if (!error && Array.isArray(data) && data[0]) results.push(data[0]);
      }

      const enriched = [];
      for (const row of results) {
        let { lat, lon } = row;
        if (lat==null || lon==null) {
          const q = row.adress || `${row.property||''}, ${row.city||''}, UK`;
          const geo = await geocodeAddress(q);
          if (geo) { lat=geo.lat; lon=geo.lon; }
        }
        if (lat!=null && lon!=null) enriched.push({ ...row, lat, lon, _kind:'prop' });
      }
      return enriched;
    }

    // ---------------- Utils ----------------
    const metersBetween = (a,b) => {
      const R=6371000,toRad=d=>d*Math.PI/180;
      const dLat=toRad(b.lat-a.lat), dLon=toRad(b.lon-a.lon);
      const la1=toRad(a.lat), la2=toRad(b.lat);
      const h=Math.sin(dLat/2)**2 + Math.cos(la1)*Math.cos(la2)*Math.sin(dLon/2)**2;
      return 2*R*Math.asin(Math.sqrt(h));
    };
    function normalizeLatLon(row){
      const lat = row.lat ?? row.latitude ?? row.Lat ?? row.Latitude;
      const lon = row.lon ?? row.lng ?? row.long ?? row.longitude ?? row.Lon ?? row.Longitude;
      return (lat!=null && lon!=null) ? {lat:Number(lat), lon:Number(lon)} : null;
    }
    function pick(row, names, fallback=null){ for (const k of names){ if (row[k]!==undefined && row[k]!==null) return row[k]; } return fallback; }

    // ---------------- University ‚Üí closest properties ----------------
    async function fetchNearestPropsByUniversity(universityName, { owner=null, orderBy='distance_walking', limit=8 } = {}){
      const { data, error } = await supabase.from('university_distance_final').select('*').limit(2000);
      if (error || !Array.isArray(data)) { console.error('[supabase] uni query error', error); return []; }

      const needle = String(universityName||'').toLowerCase();
      let rows = data.map(r => {
        const uni   = pick(r, ['University','university','uni_name','uni']);
        const city  = pick(r, ['City','city']);
        const prop  = pick(r, ['Property','property','prop_name','name']);
        const own   = pick(r, ['Owner','owner','provider']);
        const pid   = pick(r, ['propID','propId','prop_id','property_id','PropID']);
        const addrP = pick(r, ['Adress Prop','Address Prop','address_prop','property_address','AdressProp','address']);
        return {
          _raw:r, university:uni, city, property:prop, owner:own, propID:pid ?? null, addrProp:addrP,
          distance_walking: pick(r, ['distance_walking','dist_walk_m','walk_m']),
          time_walking:     pick(r, ['time_walking','walk_time_s','walk_s']),
          distance_cycling: pick(r, ['distance_cycling','cycle_m']),
          time_cycling:     pick(r, ['time_cycling','cycle_s']),
          distance_transport: pick(r, ['distance_transport','transit_m']),
          time_transport:     pick(r, ['time_transport','transit_s'])
        };
      });

      rows = rows.filter(r => r.university && String(r.university).toLowerCase().includes(needle));
      if (owner) rows = rows.filter(r => String(r.owner||'').toLowerCase() === String(owner).toLowerCase());

      const key = orderBy || 'distance_walking';
      rows.sort((a,b)=> (Number(a[key] ?? 1e15) - Number(b[key] ?? 1e15)));
      if (limit) rows = rows.slice(0, limit);

      const out = [];
      const cache = new Map();
      for (const r of rows){
        const addr = r.addrProp || `${r.property||''}, ${r.city||''}, UK`;
        if (!cache.has(addr)) cache.set(addr, await geocodeAddress(addr));
        const geo = cache.get(addr); if (!geo) continue;
        out.push({
          id: r.propID ?? r.property,
          propID: r.propID ?? null,
          property: r.property,
          city: r.city,
          owner: r.owner,
          link: null,
          lat: geo.lat, lon: geo.lon,
          distance_walking: r.distance_walking,
          time_walking: r.time_walking,
          time_cycling: r.time_cycling,
          time_transport: r.time_transport,
          _kind:'prop'
        });
      }
      return out;
    }

    // ---------------- Places near a coordinate (from places_final) ----------------
    async function fetchPlacesNear(center, { radiusMeters=800, types=[], perTypeLimit=10, propertyName=null, propID=null } = {}){
      // If a propertyName/propID is supplied, filter in SQL so we only geocode that subset.
      let q = supabase.from('places_final').select('*').limit(500);
      if (propID!=null) q = q.eq('propID', String(propID));
      else if (propertyName) q = q.ilike('Property', `%${propertyName}%`);
      const { data, error } = await q;
      if (error) { console.error('[supabase] places query error', error); return []; }

      // Decide the type column
      const typeCol = data.length ? (['type_single','type','category','kind','place_type','tag']
        .find(k => k in data[0]) || null) : null;

      // Apply optional type filter
      let rows = data;
      if (types.length && typeCol){
        const want = types.map(s => String(s).toLowerCase());
        rows = rows.filter(r => want.includes(String(r[typeCol]||'').toLowerCase()));
      }

      const buckets = new Map(); // type -> items[]
      const gcache = _geoCache;
      for (const r of rows){
        // If table has coords use them, else geocode Address
        let geo = normalizeLatLon(r);
        if (!geo && r.Address){
          const cached = gcache.get(r.Address.toLowerCase());
          geo = cached || await geocodeAddress(r.Address);
        }
        if (!geo) continue;

        const d = center ? metersBetween(center, geo) : null;
        if (center && d > radiusMeters) continue;

        const t = (typeCol ? String(r[typeCol]||'').toLowerCase() : 'poi');
        if (!buckets.has(t)) buckets.set(t, []);
        if (buckets.get(t).length >= perTypeLimit) continue;

        buckets.get(t).push({
          id: r.UID || r.name,
          name: r.name,
          address: r.Address || '',
          lat: geo.lat, lon: geo.lon,
          _type: t, _kind:'poi',
          _distance_m: d ? Math.round(d) : null
        });
      }

      return [...buckets.values()].flat().sort((a,b)=> (a._distance_m ?? 0) - (b._distance_m ?? 0));
    }

    // ---------------- Center helpers for a property ----------------
    async function centerForProperty(propertyName){
      // Try properties table first
      const { data, error } = await supabase.from('properties')
        .select('property, city, adress')
        .ilike('property', `%${propertyName}%`)
        .limit(1);
      let q = (data && data[0]) ? (data[0].adress || `${data[0].property}, ${data[0].city||''}, UK`) : propertyName;
      const geo = await geocodeAddress(q);
      return geo; // {lat,lon} or null
    }

    // ---------------- Directions helper ----------------
    async function drawRoute(from, to, { profile='walking', lineId='route-line' } = {}){
      if (!map.isStyleLoaded()) await new Promise(res => map.once('load', res));
      const url = new URL(`https://api.mapbox.com/directions/v5/mapbox/${profile}/${from.lon},${from.lat};${to.lon},${to.lat}`);
      url.searchParams.set('geometries','geojson');
      url.searchParams.set('overview','full');
      url.searchParams.set('access_token', MAPBOX_TOKEN);
      try {
        const r = await fetch(url); const j = await r.json(); const route = j?.routes?.[0];
        if (!route?.geometry) return null;
        const srcId = 'route-src';
        if (!map.getSource(srcId)){
          map.addSource(srcId, { type:'geojson', data: route.geometry });
          map.addLayer({ id: lineId, type:'line', source: srcId, paint: { 'line-width': 4, 'line-color': '#3b82f6', 'line-opacity': 0.85 } });
        } else { map.getSource(srcId).setData(route.geometry); }
        return { distance_m: route.distance, duration_s: route.duration };
      } catch(e){ console.error('directions fetch failed', e); return null; }
    }

    // ---------------- Ably subscriber ----------------
    channel.subscribe('filter_update', async (message) => {
      const p = message.data || {};
      console.log('[Ably] filter_update', p);

      // Manual viewport (optional)
      if (p.viewport?.bbox && Array.isArray(p.viewport.bbox) && p.viewport.bbox.length === 4) {
        const [minLon, minLat, maxLon, maxLat] = p.viewport.bbox;
        map.fitBounds([[minLon, minLat], [maxLon, maxLat]], { padding: 48, duration: 800 });
      } else if (p.viewport?.center) {
        map.flyTo({ center: p.viewport.center, zoom: p.viewport.zoom ?? 12, duration: 800 });
      }

      // 1) Legacy: plot by property names
      if (Array.isArray(p.properties) && p.properties.length) {
        clearMarkers();
        const rows = await fetchPropertiesByNames(p.properties);
        rows.forEach(addOrMoveMarker);
        fitToMarkers();
        return;
      }

      // 2) University ‚Üí nearest properties (plus optional POIs & route)
      if (p.uni) {
        clearMarkers();

        const props = await fetchNearestPropsByUniversity(p.uni, {
          owner: p.owner ?? null,
          orderBy: p.orderBy ?? 'distance_walking',
          limit: p.limit ?? 8
        });

        // Mark university itself for context
        const uniGeo = await geocodeAddress(`${p.uni}, UK`);
        if (uniGeo) addOrMoveMarker({ id:`uni:${p.uni}`, property:p.uni, city:'', lat:uniGeo.lat, lon:uniGeo.lon, _kind:'uni' });

        props.forEach(addOrMoveMarker);
        fitToMarkers();

        if (p.places && props[0]) {
          const center = { lat: props[0].lat, lon: props[0].lon };
          const near = await fetchPlacesNear(center, {
            radiusMeters: p.places.radiusMeters ?? 800,
            types: (p.places.types || []).map(s => String(s).toLowerCase()),
            perTypeLimit: p.places.perTypeLimit ?? 10,
            propertyName: props[0].property, // also filter by that prop in places_final if present
            propID: props[0].propID ?? null
          });
          near.forEach(addOrMoveMarker);
          fitToMarkers();
        }

        if (p.route && props[0] && uniGeo) {
          await drawRoute({ lat: props[0].lat, lon: props[0].lon }, uniGeo, { profile: p.route.profile ?? 'walking' });
        }
        return;
      }

      // 3) NEW: property-centric POIs (p.poiForProperty)
      if (p.poiForProperty?.name || p.poiForProperty?.propID){
        clearMarkers();

        // Center on the given property (by name)
        let center = null;
        if (p.poiForProperty.propID){
          // grab a name for context from places_final then center via properties table
          const { data } = await supabase.from('places_final').select('Property').eq('propID', String(p.poiForProperty.propID)).limit(1);
          const propName = data?.[0]?.Property;
          center = propName ? await centerForProperty(propName) : null;
          if (!center && propName) center = await geocodeAddress(propName);
        } else {
          center = await centerForProperty(p.poiForProperty.name) || await geocodeAddress(p.poiForProperty.name);
        }

        if (center){
          addOrMoveMarker({ id:`prop-center:${p.poiForProperty.name || p.poiForProperty.propID}`, property:(p.poiForProperty.name||'Property'), lat:center.lat, lon:center.lon, _kind:'prop' });
        }

        const near = await fetchPlacesNear(center, {
          propertyName: p.poiForProperty.name || null,
          propID: p.poiForProperty.propID ?? null,
          radiusMeters: p.poiForProperty.radiusMeters ?? 800,
          types: (p.poiForProperty.types || []).map(s => String(s).toLowerCase()),
          perTypeLimit: p.poiForProperty.perTypeLimit ?? 10
        });

        near.forEach(addOrMoveMarker);
        fitToMarkers();
        return;
      }
    });

    // Console helper
    window._debugPublish = (payloadOrNames) => {
      const sid = document.getElementById('sid').textContent;
      const ch  = ably.channels.get(`filters:${sid}`);
      if (Array.isArray(payloadOrNames)) ch.publish('filter_update', { properties: payloadOrNames });
      else ch.publish('filter_update', payloadOrNames);
    };
  </script>
</body>
</html>